// Layout of Contract:
// version
// imports
// errors
// interfaces, libraries, contracts
// Type declarations
// State variables
// Events
// Modifiers
// Functions

// Layout of Functions:
// constructor
// receive function (if exists)
// fallback function (if exists)
// external
// public
// internal
// private
// internal & private view & pure functions
// external & public view & pure functions
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {ERC20} from "@openzeppelin/contracts/contracts/token/ERC20/ERC20.sol";
import {Ownable} from "@openzeppelin/contracts/contracts/access/Ownable.sol";
import {AccessControl} from "@openzeppelin/contracts/contracts/access/AccessControl.sol";

/**
 * @title RebaseToken
 * @author Aasif
 * @notice This is a cross-chain rebase token that incentivises users to deposit into vault and gain interest in rewards.
 * @notice The interest rate in the smart contract can only decrease.
 * @notice Each user will have their own interest rate that is the global interest rate at the time of depositing.
 */
contract RebaseToken is ERC20, Ownable, AccessControl {
    error RebaseToken__InterestRateCanOnlyDecrease(uint256 oldInterestRate, uint256 newInterestRate);

    uint256 private constant PRECISION_FACTOR = 1e18;
    bytes32 private constant MINT_AND_BURN_ROLE = keccak256("MINT_AND_BURN_ROLE");
    uint256 private s_interestRate = 5e10;
    mapping(address => uint256) private s_usersInterestRate;
    mapping(address => uint256) private s_userLastUpdatedTimeStamp;

    event InterestRateSet(uint256 indexed newInterestRate);

    constructor() ERC20("Rebase Token", "RBT") Ownable(msg.sender) {}

    function granMintAndBurnRole(address _user) external onlyOwner {
        _grantRole(MINT_AND_BURN_ROLE, _user);
    }

    /**
     * @notice Set the interest rate in the contract
     * @param _newInterestRate The new interest rate to set
     * @dev The interest rate can only decrease
     */
    function setInterestRate(uint256 _newInterestRate) external onlyOwner {
        if (_newInterestRate >= s_interestRate) {
            revert RebaseToken__InterestRateCanOnlyDecrease(s_interestRate, _newInterestRate);
        }
        s_interestRate = _newInterestRate;
        emit InterestRateSet(_newInterestRate);
    }
    /**
     * @notice Get the principle balance of a user. This is the number of tokens that have currently been minted to the user, not including any interest that has accrued since the last time the user interacted with the protocol.
     * @param _user The address of the user whose principle balance to get
     * @return The principle balance of the user
     */

    function principleBalanceOf(address _user) external view returns (uint256) {
        return super.balanceOf(_user);
    }
    /**
     *
     * @param _to The address of the User want to mint
     * @param amount The amount of token user wants to mint
     */

    function mint(address _to, uint256 amount, uint256 _userInterestRate) external onlyRole(MINT_AND_BURN_ROLE) {
        _mintAccruedInterest(_to);
        s_usersInterestRate[_to] = _userInterestRate;
        _mint(_to, amount);
    }
    /**
     * @notice Burn the user tokens when they withdraw from the vault
     * @param _from The address from which to burn the tokens
     * @param amount The amount of tokens to burn
     */

    function burn(address _from, uint256 amount) external onlyRole(MINT_AND_BURN_ROLE) {
        _mintAccruedInterest(_from);
        _burn(_from, amount);
    }

    /**
     * @dev calculates the balance of the user, which is the
     * principal balance + interest generated by the principal balance
     * @param _user the user for which the balance is being calculated
     * @return  The total balance of the user
     *
     */
    function balanceOf(address _user) public view override returns (uint256) {
        // it's simple math, super.balanceOf(user) gets the total tokens minted by user
        // if we want total balance of the user, that will be balanceOf(user) + balanceOf(user)*interestPerSecond*timeElapsed
        // taking balanceOf(user) common we get => balanceOf(user)(1 + (interestPerSecond*timeElapsed))
        // we get the balanceOf(user) with this super keyword, and the rest with the function
        return super.balanceOf(_user) * _calculateUserAccumulatedInterestSinceLastUpdate(_user) / PRECISION_FACTOR;
    }
    /**
     * @notice Transfer tokens from one user to another
     * @param _receipient The address of the person to send the tokens to
     * @param _amount The amount of the tokens to send
     * @return True if the transfer was successfull
     */

    function transfer(address _receipient, uint256 _amount) public override returns (bool) {
        _mintAccruedInterest(msg.sender);
        _mintAccruedInterest(_receipient);
        if (_amount == type(uint256).max) {
            _amount = balanceOf(msg.sender);
        }
        if (balanceOf(_receipient) == 0) {
            s_usersInterestRate[_receipient] = s_usersInterestRate[msg.sender];
        }
        return super.transfer(_receipient, _amount);
    }
    /**
     * @notice Transfer tokens from one user to another
     * @param _sender The address of user to sender tokens from
     * @param _receipient The address of the user to send tokens to
     * @param _amount The amount of tokens to Send
     */

    function transferFrom(address _sender, address _receipient, uint256 _amount) public override returns (bool) {
        _mintAccruedInterest(_sender);
        _mintAccruedInterest(_receipient);
        if (_amount == type(uint256).max) {
            _amount = balanceOf(_sender);
        }
        if (balanceOf(_receipient) == 0) {
            s_usersInterestRate[_receipient] = s_usersInterestRate[_sender];
        }
        return super.transferFrom(_sender, _receipient, _amount);
    }
    /**
     *
     * @notice Calculate the interest rate that has accumulated since the last update
     * @param _user The user to calculate the interest accumulated for
     * @return linearInterest The interest that has accumulated since the last update
     */

    function _calculateUserAccumulatedInterestSinceLastUpdate(address _user)
        internal
        view
        returns (uint256 linearInterest)
    {
        // we will calculate only the accumulated interest here
        // let's say if someone deposited:: 10 tokens, and interestRate:: 0.5 (50%) and time elapsed:: 2 seconds, so
        // 10 + 10 * 0.5 * 2 (deposited + (deposited * interestRate * timeElapsed))
        // if we do simple math here, taking deposited common, so it will be deposited(1 + (interestRate * timeElapsed));
        // so the total interest will be 1 + (interestRate * timeElapsed) which will then be multiplied with the actual amount of token minted to get the total amount
        uint256 timeElapsed = block.timestamp - s_userLastUpdatedTimeStamp[_user];
        linearInterest = PRECISION_FACTOR + (s_usersInterestRate[_user] * timeElapsed); //as we want this precised into 1e18, instead of 1, we are using 1e18 i.e. PRECISION_FACTOR
        return linearInterest;
    }
    /**
     *
     * @notice Mint the accrued interest to the user since the last time they interacted with protocol
     * @param _user The address of the user to whom the accrued interest should be minted
     */

    function _mintAccruedInterest(address _user) internal {
        // 1. find the current balance of user's rebase tokens that have been minted to the user -> principle balance
        uint256 previousPrincipleBalance = super.balanceOf(_user);
        // 2. calculate their current balance including any interest i.e. principle balance + interest balance -> then total - principle balance => tokens to mint to user
        uint256 currentBalance = balanceOf(_user);
        // calculate the numbers of tokens to be minted to the user
        uint256 balanceIncrease = currentBalance - previousPrincipleBalance;
        // set the users last updated timestamp
        s_userLastUpdatedTimeStamp[_user] = block.timestamp;
        // call the _mint function to mint the tokens to user
        _mint(_user, balanceIncrease);
    }

    function getInterestRate() external view returns (uint256) {
        return s_interestRate;
    }

    function getUsersInterestRate(address user) external view returns (uint256) {
        return s_usersInterestRate[user];
    }
}
